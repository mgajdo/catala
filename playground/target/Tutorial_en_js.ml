(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime_ocaml.Runtime
open Runtime_jsoo.Runtime
open Js_of_ocaml
open Tutorial_en

[@@@ocaml.warning "-4-26-27-32-41-42"]

(* Generated API *)

class type taxCredit =
  object
    method kind :
      Js.js_string Js.t Js.readonly_prop
      (** Expects one of:
        - "NoTaxCredit"
        - "ChildrenTaxCredit" *)
    
    method payload : Js.Unsafe.any Js.t Js.readonly_prop
  end

let taxCredit_to_js : TaxCredit.t -> taxCredit Js.t
  = function
  | NoTaxCredit arg -> object%js
      val kind = Js.string "NoTaxCredit"
      val payload = Js.Unsafe.coerce (Js.Unsafe.inject ( arg))
    end
  | ChildrenTaxCredit arg -> object%js
      val kind = Js.string "ChildrenTaxCredit"
      val payload = Js.Unsafe.coerce (Js.Unsafe.inject (integer_to_int arg))
    end

let taxCredit_of_js (taxCredit : taxCredit Js.t) : TaxCredit.t =
  match taxCredit##.kind |> Js.to_string with
  | "NoTaxCredit" -> TaxCredit.NoTaxCredit ()
  | "ChildrenTaxCredit" ->
  TaxCredit.ChildrenTaxCredit (integer_of_int (Js.Unsafe.coerce taxCredit##.payload))
  | cons ->
    failwith
      (Printf.sprintf
        "Unexpected '%s' kind for the enumeration 'TaxCredit.t'" cons)


class type individual =
  object
    method income: Js.number Js.t Js.readonly_prop
    method numberOfChildren: int Js.readonly_prop
  end
  let individual_to_js (individual : Individual.t) : individual Js.t =
    object%js
      val income = Js.number_of_float @@ money_to_float individual.income
      val numberOfChildren = integer_to_int individual.number_of_children
      end
  let individual_of_js (individual : individual Js.t) : Individual.t =
    {
      income =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          individual##.income;
      number_of_children = integer_of_int individual##.numberOfChildren
    }

class type incomeTaxComputation =
  object method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let incomeTaxComputation_to_js (incomeTaxComputation
    : IncomeTaxComputation.t) : incomeTaxComputation Js.t =
    object%js
      val incomeTax =
        Js.number_of_float @@ money_to_float incomeTaxComputation.income_tax
      end
  let incomeTaxComputation_of_js
    (incomeTaxComputation : incomeTaxComputation Js.t) :
    IncomeTaxComputation.t =
    {
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          incomeTaxComputation##.incomeTax
    }

class type child =
  object method isEligibleArticle3: bool Js.t Js.readonly_prop
  end
  let child_to_js (child : Child.t) : child Js.t =
    object%js
      val isEligibleArticle3 = Js.bool child.is_eligible_article_3
      end
  let child_of_js (child : child Js.t) : Child.t =
    {is_eligible_article_3 = Js.to_bool child##.isEligibleArticle3
    }

class type twoBrackets =
  object
    method breakpoint: Js.number Js.t Js.readonly_prop
    method rate1: Js.number Js.t Js.readonly_prop
    method rate2: Js.number Js.t Js.readonly_prop
  end
  let twoBrackets_to_js (twoBrackets : TwoBrackets.t) : twoBrackets Js.t =
    object%js
      val breakpoint =
        Js.number_of_float @@ money_to_float twoBrackets.breakpoint
      val rate1 = Js.number_of_float @@ decimal_to_float twoBrackets.rate1
      val rate2 = Js.number_of_float @@ decimal_to_float twoBrackets.rate2
      end
  let twoBrackets_of_js (twoBrackets : twoBrackets Js.t) : TwoBrackets.t =
    {
      breakpoint =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          twoBrackets##.breakpoint;
      rate1 = decimal_of_float @@ Js.float_of_number twoBrackets##.rate1;
      rate2 = decimal_of_float @@ Js.float_of_number twoBrackets##.rate2
    }

class type twoBracketsTaxComputation =
  object
    method taxFormula:
      (unit,  Js.number Js.t -> Js.number Js.t) Js.meth_callback Js.meth
  end
  let twoBracketsTaxComputation_to_js (twoBracketsTaxComputation
    : TwoBracketsTaxComputation.t) : twoBracketsTaxComputation Js.t =
    object%js
      method taxFormula = Js.wrap_meth_callback
        (
          fun _ (function_input0: Js.number Js.t) ->
          Js.number_of_float @@ money_to_float (twoBracketsTaxComputation.tax_formula 
          (money_of_decimal @@ decimal_of_float @@ Js.float_of_number
            function_input0)))
      end
  let twoBracketsTaxComputation_of_js
    (twoBracketsTaxComputation : twoBracketsTaxComputation Js.t) :
    TwoBracketsTaxComputation.t =
    {
      tax_formula = failwith "The function 'tax_formula' translation isn't yet supported..."
    }

class type newIncomeTaxComputation =
  object method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let newIncomeTaxComputation_to_js (newIncomeTaxComputation
    : NewIncomeTaxComputation.t) : newIncomeTaxComputation Js.t =
    object%js
      val incomeTax =
        Js.number_of_float @@ money_to_float newIncomeTaxComputation.income_tax
      end
  let newIncomeTaxComputation_of_js
    (newIncomeTaxComputation : newIncomeTaxComputation Js.t) :
    NewIncomeTaxComputation.t =
    {
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          newIncomeTaxComputation##.incomeTax
    }

class type test1 =
  object method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let test1_to_js (test1 : Test1.t) : test1 Js.t =
    object%js
      val incomeTax = Js.number_of_float @@ money_to_float test1.income_tax
      end
  let test1_of_js (test1 : test1 Js.t) : Test1.t =
    {
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          test1##.incomeTax
    }

class type test2 =
  object method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let test2_to_js (test2 : Test2.t) : test2 Js.t =
    object%js
      val incomeTax = Js.number_of_float @@ money_to_float test2.income_tax
      end
  let test2_of_js (test2 : test2 Js.t) : Test2.t =
    {
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          test2##.incomeTax
    }

class type newIncomeTaxComputationFixed =
  object
    method taxFormula:
      (unit,  Js.number Js.t -> Js.number Js.t) Js.meth_callback Js.meth
    method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let newIncomeTaxComputationFixed_to_js (newIncomeTaxComputationFixed
    : NewIncomeTaxComputationFixed.t) : newIncomeTaxComputationFixed Js.t =
    object%js
      method taxFormula = Js.wrap_meth_callback
        (
          fun _ (function_input0: Js.number Js.t) ->
          Js.number_of_float @@ money_to_float (newIncomeTaxComputationFixed.tax_formula 
          (money_of_decimal @@ decimal_of_float @@ Js.float_of_number
            function_input0)))
      val incomeTax =
        Js.number_of_float @@ money_to_float newIncomeTaxComputationFixed.income_tax
      end
  let newIncomeTaxComputationFixed_of_js
    (newIncomeTaxComputationFixed : newIncomeTaxComputationFixed Js.t) :
    NewIncomeTaxComputationFixed.t =
    {
      tax_formula = failwith "The function 'tax_formula' translation isn't yet supported...";
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          newIncomeTaxComputationFixed##.incomeTax
    }

class type test3 =
  object method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let test3_to_js (test3 : Test3.t) : test3 Js.t =
    object%js
      val incomeTax = Js.number_of_float @@ money_to_float test3.income_tax
      end
  let test3_of_js (test3 : test3 Js.t) : Test3.t =
    {
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          test3##.incomeTax
    }

class type test4 =
  object method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let test4_to_js (test4 : Test4.t) : test4 Js.t =
    object%js
      val incomeTax = Js.number_of_float @@ money_to_float test4.income_tax
      end
  let test4_of_js (test4 : test4 Js.t) : Test4.t =
    {
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          test4##.incomeTax
    }

class type test5 =
  object method incomeTax: Js.number Js.t Js.readonly_prop
  end
  let test5_to_js (test5 : Test5.t) : test5 Js.t =
    object%js
      val incomeTax = Js.number_of_float @@ money_to_float test5.income_tax
      end
  let test5_of_js (test5 : test5 Js.t) : Test5.t =
    {
      income_tax =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          test5##.incomeTax
    }

class type basisForFineDetermination =
  object method basisForFine: Js.number Js.t Js.readonly_prop
  end
  let basisForFineDetermination_to_js (basisForFineDetermination
    : BasisForFineDetermination.t) : basisForFineDetermination Js.t =
    object%js
      val basisForFine =
        Js.number_of_float @@ money_to_float basisForFineDetermination.basis_for_fine
      end
  let basisForFineDetermination_of_js
    (basisForFineDetermination : basisForFineDetermination Js.t) :
    BasisForFineDetermination.t =
    {
      basis_for_fine =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          basisForFineDetermination##.basisForFine
    }

class type booleanValues =
  object
    method value1: bool Js.t Js.readonly_prop
    method value2: bool Js.t Js.readonly_prop
  end
  let booleanValues_to_js (booleanValues : BooleanValues.t)
    : booleanValues Js.t =
    object%js
      val value1 = Js.bool booleanValues.value1
      val value2 = Js.bool booleanValues.value2
      end
  let booleanValues_of_js (booleanValues : booleanValues Js.t) :
    BooleanValues.t =
    {
      value1 = Js.to_bool booleanValues##.value1;
      value2 = Js.to_bool booleanValues##.value2
    }

class type integerValues =
  object
    method value1: int Js.readonly_prop
    method value2: int Js.readonly_prop
  end
  let integerValues_to_js (integerValues : IntegerValues.t)
    : integerValues Js.t =
    object%js
      val value1 = integer_to_int integerValues.value1
      val value2 = integer_to_int integerValues.value2
      end
  let integerValues_of_js (integerValues : integerValues Js.t) :
    IntegerValues.t =
    {
      value1 = integer_of_int integerValues##.value1;
      value2 = integer_of_int integerValues##.value2
    }

class type decimalValues =
  object
    method value1: Js.number Js.t Js.readonly_prop
    method value2: Js.number Js.t Js.readonly_prop
  end
  let decimalValues_to_js (decimalValues : DecimalValues.t)
    : decimalValues Js.t =
    object%js
      val value1 =
        Js.number_of_float @@ decimal_to_float decimalValues.value1
      val value2 =
        Js.number_of_float @@ decimal_to_float decimalValues.value2
      end
  let decimalValues_of_js (decimalValues : decimalValues Js.t) :
    DecimalValues.t =
    {
      value1 = decimal_of_float @@ Js.float_of_number decimalValues##.value1;
      value2 = decimal_of_float @@ Js.float_of_number decimalValues##.value2
    }

class type moneyValues =
  object
    method value1: Js.number Js.t Js.readonly_prop
    method value2: Js.number Js.t Js.readonly_prop
  end
  let moneyValues_to_js (moneyValues : MoneyValues.t) : moneyValues Js.t =
    object%js
      val value1 = Js.number_of_float @@ decimal_to_float moneyValues.value1
      val value2 = Js.number_of_float @@ money_to_float moneyValues.value2
      end
  let moneyValues_of_js (moneyValues : moneyValues Js.t) : MoneyValues.t =
    {
      value1 = decimal_of_float @@ Js.float_of_number moneyValues##.value1;
      value2 =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          moneyValues##.value2
    }

class type dateValues =
  object
    method value1: Js.js_string Js.t Js.readonly_prop
    method value2: Runtime_jsoo.Runtime.duration Js.t Js.readonly_prop
  end
  let dateValues_to_js (dateValues : DateValues.t) : dateValues Js.t =
    object%js
      val value1 = date_to_js dateValues.value1
      val value2 = duration_to_js dateValues.value2
      end
  let dateValues_of_js (dateValues : dateValues Js.t) : DateValues.t =
    {
      value1 = date_of_js dateValues##.value1;
      value2 = duration_of_js dateValues##.value2
    }

class type ambiguousDate =
  object method result: Js.js_string Js.t Js.readonly_prop
  end
  let ambiguousDate_to_js (ambiguousDate : AmbiguousDate.t)
    : ambiguousDate Js.t =
    object%js
      val result = date_to_js ambiguousDate.result
      end
  let ambiguousDate_of_js (ambiguousDate : ambiguousDate Js.t) :
    AmbiguousDate.t = {result = date_of_js ambiguousDate##.result
    }

class type ambiguousDate2 =
  object method result: Js.js_string Js.t Js.readonly_prop
  end
  let ambiguousDate2_to_js (ambiguousDate2 : AmbiguousDate2.t)
    : ambiguousDate2 Js.t =
    object%js
      val result = date_to_js ambiguousDate2.result
      end
  let ambiguousDate2_of_js (ambiguousDate2 : ambiguousDate2 Js.t) :
    AmbiguousDate2.t = {result = date_of_js ambiguousDate2##.result
    }

class type ambiguousDate3 =
  object method result: bool Js.t Js.readonly_prop
  end
  let ambiguousDate3_to_js (ambiguousDate3 : AmbiguousDate3.t)
    : ambiguousDate3 Js.t =
    object%js
      val result = Js.bool ambiguousDate3.result
      end
  let ambiguousDate3_of_js (ambiguousDate3 : ambiguousDate3 Js.t) :
    AmbiguousDate3.t = {result = Js.to_bool ambiguousDate3##.result
    }

class type listValues =
  object
    method moreValues: int Js.js_array Js.t Js.readonly_prop
    method total: int Js.readonly_prop
    method average: Js.number Js.t Js.readonly_prop
    method positiveValues: int Js.js_array Js.t Js.readonly_prop
    method relativeValues: Js.number Js.t Js.js_array Js.t Js.readonly_prop
  end
  let listValues_to_js (listValues : ListValues.t) : listValues Js.t =
    object%js
      val moreValues =
        Js.array @@ Array.map (fun x -> integer_to_int x) listValues.more_values
      val total = integer_to_int listValues.total
      val average = Js.number_of_float @@ decimal_to_float listValues.average
      val positiveValues =
        Js.array @@ Array.map (fun x -> integer_to_int x) listValues.positive_values
      val relativeValues =
        Js.array @@ Array.map (fun x -> Js.number_of_float @@ decimal_to_float x) listValues.relative_values
      end
  let listValues_of_js (listValues : listValues Js.t) : ListValues.t =
    {
      more_values =
        Array.map (fun x -> integer_of_int x) @@ Js.to_array
          listValues##.moreValues;
      total = integer_of_int listValues##.total;
      average = decimal_of_float @@ Js.float_of_number listValues##.average;
      positive_values =
        Array.map (fun x -> integer_of_int x) @@ Js.to_array
          listValues##.positiveValues;
      relative_values =
        Array.map (fun x -> decimal_of_float @@ Js.float_of_number x) @@ Js.to_array
          listValues##.relativeValues
    }

class type useOfTuple =
  object method when1: Js.js_string Js.t Js.readonly_prop
  end
  let useOfTuple_to_js (useOfTuple : UseOfTuple.t) : useOfTuple Js.t =
    object%js
      val when1 = date_to_js useOfTuple.when1
      end
  let useOfTuple_of_js (useOfTuple : useOfTuple Js.t) : UseOfTuple.t =
    {when1 = date_of_js useOfTuple##.when1
    }

class type applyRates =
  object method result: Js.number Js.t Js.js_array Js.t Js.readonly_prop
  end
  let applyRates_to_js (applyRates : ApplyRates.t) : applyRates Js.t =
    object%js
      val result =
        Js.array @@ Array.map (fun x -> Js.number_of_float @@ money_to_float x) applyRates.result
      end
  let applyRates_of_js (applyRates : applyRates Js.t) : ApplyRates.t =
    {
      result =
        Array.map (fun x -> money_of_decimal @@ decimal_of_float @@ Js.float_of_number x) @@ Js.to_array
          applyRates##.result
    }

class type includeInGrossIncome =
  object method amountToInclude: Js.number Js.t Js.readonly_prop
  end
  let includeInGrossIncome_to_js (includeInGrossIncome
    : IncludeInGrossIncome.t) : includeInGrossIncome Js.t =
    object%js
      val amountToInclude =
        Js.number_of_float @@ money_to_float includeInGrossIncome.amount_to_include
      end
  let includeInGrossIncome_of_js
    (includeInGrossIncome : includeInGrossIncome Js.t) :
    IncludeInGrossIncome.t =
    {
      amount_to_include =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          includeInGrossIncome##.amountToInclude
    }

class type test4bis =
  object
    method taxComputation: newIncomeTaxComputationFixed Js.t Js.readonly_prop
  end
  let test4bis_to_js (test4bis : Test4bis.t) : test4bis Js.t =
    object%js
      val taxComputation =
        newIncomeTaxComputationFixed_to_js test4bis.tax_computation
      end
  let test4bis_of_js (test4bis : test4bis Js.t) : Test4bis.t =
    {
      tax_computation =
        newIncomeTaxComputationFixed_of_js test4bis##.taxComputation
    }

class type incomeTaxComputation_in =
  object method individualIn: individual Js.t Js.readonly_prop
  end
  let incomeTaxComputation_in_to_js (incomeTaxComputation_in
    : IncomeTaxComputation_in.t) : incomeTaxComputation_in Js.t =
    object%js
      val individualIn =
        individual_to_js incomeTaxComputation_in.individual_in
      end
  let incomeTaxComputation_in_of_js
    (incomeTaxComputation_in : incomeTaxComputation_in Js.t) :
    IncomeTaxComputation_in.t =
    {individual_in = individual_of_js incomeTaxComputation_in##.individualIn
    }

class type child_in =
  object method ageIn: int Js.readonly_prop
  end
  let child_in_to_js (child_in : Child_in.t) : child_in Js.t =
    object%js
      val ageIn = integer_to_int child_in.age_in
      end
  let child_in_of_js (child_in : child_in Js.t) : Child_in.t =
    {age_in = integer_of_int child_in##.ageIn
    }

class type twoBracketsTaxComputation_in =
  object method bracketsIn: twoBrackets Js.t Js.readonly_prop
  end
  let twoBracketsTaxComputation_in_to_js (twoBracketsTaxComputation_in
    : TwoBracketsTaxComputation_in.t) : twoBracketsTaxComputation_in Js.t =
    object%js
      val bracketsIn =
        twoBrackets_to_js twoBracketsTaxComputation_in.brackets_in
      end
  let twoBracketsTaxComputation_in_of_js
    (twoBracketsTaxComputation_in : twoBracketsTaxComputation_in Js.t) :
    TwoBracketsTaxComputation_in.t =
    {
      brackets_in =
        twoBrackets_of_js twoBracketsTaxComputation_in##.bracketsIn
    }

class type newIncomeTaxComputation_in =
  object method individualIn: individual Js.t Js.readonly_prop
  end
  let newIncomeTaxComputation_in_to_js (newIncomeTaxComputation_in
    : NewIncomeTaxComputation_in.t) : newIncomeTaxComputation_in Js.t =
    object%js
      val individualIn =
        individual_to_js newIncomeTaxComputation_in.individual_in
      end
  let newIncomeTaxComputation_in_of_js
    (newIncomeTaxComputation_in : newIncomeTaxComputation_in Js.t) :
    NewIncomeTaxComputation_in.t =
    {
      individual_in =
        individual_of_js newIncomeTaxComputation_in##.individualIn
    }

class type test1_in =
object end
let test1_in_to_js (_ : Test1_in.t) : test1_in Js.t = object%js end
let test1_in_of_js (_ : test1_in Js.t) : Test1_in.t = ()
class type test2_in =
object end
let test2_in_to_js (_ : Test2_in.t) : test2_in Js.t = object%js end
let test2_in_of_js (_ : test2_in Js.t) : Test2_in.t = ()
class type newIncomeTaxComputationFixed_in =
  object
    method individualIn: individual Js.t Js.readonly_prop
    method incomeTaxIn:
      (unit,  unit -> (Js.number Js.t) Js.opt) Js.meth_callback Js.meth
  end
  let newIncomeTaxComputationFixed_in_to_js (newIncomeTaxComputationFixed_in
    : NewIncomeTaxComputationFixed_in.t)
    : newIncomeTaxComputationFixed_in Js.t =
    object%js
      val individualIn =
        individual_to_js newIncomeTaxComputationFixed_in.individual_in
      method incomeTaxIn = Js.wrap_meth_callback
        (
          fun _ (function_input0: unit) ->
          (function Eoption.ENone () -> Js.null | Eoption.ESome x -> Js.some (Js.number_of_float @@ money_to_float x)) (newIncomeTaxComputationFixed_in.income_tax_in 
          (
            function_input0)))
      end
  let newIncomeTaxComputationFixed_in_of_js
    (newIncomeTaxComputationFixed_in : newIncomeTaxComputationFixed_in Js.t) :
    NewIncomeTaxComputationFixed_in.t =
    {
      individual_in =
        individual_of_js newIncomeTaxComputationFixed_in##.individualIn;
      income_tax_in = failwith "The function 'income_tax_in' translation isn't yet supported..."
    }

class type test3_in =
object end
let test3_in_to_js (_ : Test3_in.t) : test3_in Js.t = object%js end
let test3_in_of_js (_ : test3_in Js.t) : Test3_in.t = ()
class type test4_in =
object end
let test4_in_to_js (_ : Test4_in.t) : test4_in Js.t = object%js end
let test4_in_of_js (_ : test4_in Js.t) : Test4_in.t = ()
class type test5_in =
object end
let test5_in_to_js (_ : Test5_in.t) : test5_in Js.t = object%js end
let test5_in_of_js (_ : test5_in Js.t) : Test5_in.t = ()
class type test4bis_in =
object end
let test4bis_in_to_js (_ : Test4bis_in.t) : test4bis_in Js.t = object%js end
let test4bis_in_of_js (_ : test4bis_in Js.t) : Test4bis_in.t = ()
class type basisForFineDetermination_in =
  object method individualIn: individual Js.t Js.readonly_prop
  end
  let basisForFineDetermination_in_to_js (basisForFineDetermination_in
    : BasisForFineDetermination_in.t) : basisForFineDetermination_in Js.t =
    object%js
      val individualIn =
        individual_to_js basisForFineDetermination_in.individual_in
      end
  let basisForFineDetermination_in_of_js
    (basisForFineDetermination_in : basisForFineDetermination_in Js.t) :
    BasisForFineDetermination_in.t =
    {
      individual_in =
        individual_of_js basisForFineDetermination_in##.individualIn
    }

class type wealthTax_in =
  object
    method valueOfBuildingsUsedForCharityIn: Js.number Js.t Js.readonly_prop
    method totalWealthIn: Js.number Js.t Js.readonly_prop
  end
  let wealthTax_in_to_js (wealthTax_in : WealthTax_in.t)
    : wealthTax_in Js.t =
    object%js
      val valueOfBuildingsUsedForCharityIn =
        Js.number_of_float @@ money_to_float wealthTax_in.value_of_buildings_used_for_charity_in
      val totalWealthIn =
        Js.number_of_float @@ money_to_float wealthTax_in.total_wealth_in
      end
  let wealthTax_in_of_js (wealthTax_in : wealthTax_in Js.t) :
    WealthTax_in.t =
    {
      value_of_buildings_used_for_charity_in =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          wealthTax_in##.valueOfBuildingsUsedForCharityIn;
      total_wealth_in =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          wealthTax_in##.totalWealthIn
    }

class type wealthTax =
object end
let wealthTax_to_js (_ : WealthTax.t) : wealthTax Js.t = object%js end
let wealthTax_of_js (_ : wealthTax Js.t) : WealthTax.t = ()
class type booleanValues_in =
object end
let booleanValues_in_to_js (_ : BooleanValues_in.t) : booleanValues_in Js.t = object%js end
let booleanValues_in_of_js (_ : booleanValues_in Js.t) : BooleanValues_in.t = ()
class type integerValues_in =
object end
let integerValues_in_to_js (_ : IntegerValues_in.t) : integerValues_in Js.t = object%js end
let integerValues_in_of_js (_ : integerValues_in Js.t) : IntegerValues_in.t = ()
class type decimalValues_in =
object end
let decimalValues_in_to_js (_ : DecimalValues_in.t) : decimalValues_in Js.t = object%js end
let decimalValues_in_of_js (_ : decimalValues_in Js.t) : DecimalValues_in.t = ()
class type moneyValues_in =
object end
let moneyValues_in_to_js (_ : MoneyValues_in.t) : moneyValues_in Js.t = object%js end
let moneyValues_in_of_js (_ : moneyValues_in Js.t) : MoneyValues_in.t = ()
class type dateValues_in =
object end
let dateValues_in_to_js (_ : DateValues_in.t) : dateValues_in Js.t = object%js end
let dateValues_in_of_js (_ : dateValues_in Js.t) : DateValues_in.t = ()
class type ambiguousDate_in =
object end
let ambiguousDate_in_to_js (_ : AmbiguousDate_in.t) : ambiguousDate_in Js.t = object%js end
let ambiguousDate_in_of_js (_ : ambiguousDate_in Js.t) : AmbiguousDate_in.t = ()
class type ambiguousDate2_in =
object end
let ambiguousDate2_in_to_js (_ : AmbiguousDate2_in.t) : ambiguousDate2_in Js.t = object%js end
let ambiguousDate2_in_of_js (_ : ambiguousDate2_in Js.t) : AmbiguousDate2_in.t = ()
class type ambiguousDate3_in =
object end
let ambiguousDate3_in_to_js (_ : AmbiguousDate3_in.t) : ambiguousDate3_in Js.t = object%js end
let ambiguousDate3_in_of_js (_ : ambiguousDate3_in Js.t) : AmbiguousDate3_in.t = ()
class type listValues_in =
object end
let listValues_in_to_js (_ : ListValues_in.t) : listValues_in Js.t = object%js end
let listValues_in_of_js (_ : listValues_in Js.t) : ListValues_in.t = ()
class type useOfTuple_in =
object end
let useOfTuple_in_to_js (_ : UseOfTuple_in.t) : useOfTuple_in Js.t = object%js end
let useOfTuple_in_of_js (_ : useOfTuple_in Js.t) : UseOfTuple_in.t = ()
class type applyRates_in =
  object
    method valuesIn: Js.number Js.t Js.js_array Js.t Js.readonly_prop
    method ratesIn: Js.number Js.t Js.js_array Js.t Js.readonly_prop
  end
  let applyRates_in_to_js (applyRates_in : ApplyRates_in.t)
    : applyRates_in Js.t =
    object%js
      val valuesIn =
        Js.array @@ Array.map (fun x -> Js.number_of_float @@ money_to_float x) applyRates_in.values_in
      val ratesIn =
        Js.array @@ Array.map (fun x -> Js.number_of_float @@ decimal_to_float x) applyRates_in.rates_in
      end
  let applyRates_in_of_js (applyRates_in : applyRates_in Js.t) :
    ApplyRates_in.t =
    {
      values_in =
        Array.map (fun x -> money_of_decimal @@ decimal_of_float @@ Js.float_of_number x) @@ Js.to_array
          applyRates_in##.valuesIn;
      rates_in =
        Array.map (fun x -> decimal_of_float @@ Js.float_of_number x) @@ Js.to_array
          applyRates_in##.ratesIn
    }

class type includeInGrossIncome_in =
  object
    method fairMarketValueIn: Js.number Js.t Js.readonly_prop
    method amountPaidIn: Js.number Js.t Js.readonly_prop
  end
  let includeInGrossIncome_in_to_js (includeInGrossIncome_in
    : IncludeInGrossIncome_in.t) : includeInGrossIncome_in Js.t =
    object%js
      val fairMarketValueIn =
        Js.number_of_float @@ money_to_float includeInGrossIncome_in.fair_market_value_in
      val amountPaidIn =
        Js.number_of_float @@ money_to_float includeInGrossIncome_in.amount_paid_in
      end
  let includeInGrossIncome_in_of_js
    (includeInGrossIncome_in : includeInGrossIncome_in Js.t) :
    IncludeInGrossIncome_in.t =
    {
      fair_market_value_in =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          includeInGrossIncome_in##.fairMarketValueIn;
      amount_paid_in =
        money_of_decimal @@ decimal_of_float @@ Js.float_of_number
          includeInGrossIncome_in##.amountPaidIn
    }




let income_tax_computation
  (incomeTaxComputation_in : incomeTaxComputation_in Js.t)
  : incomeTaxComputation Js.t =
  execute_or_throw_error
    (fun () ->
       incomeTaxComputation_in
       |> incomeTaxComputation_in_of_js
       |> income_tax_computation
       |> incomeTaxComputation_to_js)


let child (child_in : child_in Js.t)
  : child Js.t =
  execute_or_throw_error
    (fun () -> child_in |> child_in_of_js |> child |> child_to_js)


let two_brackets_tax_computation
  (twoBracketsTaxComputation_in : twoBracketsTaxComputation_in Js.t)
  : twoBracketsTaxComputation Js.t =
  execute_or_throw_error
    (fun () ->
       twoBracketsTaxComputation_in
       |> twoBracketsTaxComputation_in_of_js
       |> two_brackets_tax_computation
       |> twoBracketsTaxComputation_to_js)


let wealth_tax (wealthTax_in : wealthTax_in Js.t)
  : wealthTax Js.t =
  execute_or_throw_error
    (fun () ->
       wealthTax_in
       |> wealthTax_in_of_js
       |> wealth_tax
       |> wealthTax_to_js)


let boolean_values (booleanValues_in : booleanValues_in Js.t)
  : booleanValues Js.t =
  execute_or_throw_error
    (fun () ->
       booleanValues_in
       |> booleanValues_in_of_js
       |> boolean_values
       |> booleanValues_to_js)


let integer_values (integerValues_in : integerValues_in Js.t)
  : integerValues Js.t =
  execute_or_throw_error
    (fun () ->
       integerValues_in
       |> integerValues_in_of_js
       |> integer_values
       |> integerValues_to_js)


let decimal_values (decimalValues_in : decimalValues_in Js.t)
  : decimalValues Js.t =
  execute_or_throw_error
    (fun () ->
       decimalValues_in
       |> decimalValues_in_of_js
       |> decimal_values
       |> decimalValues_to_js)


let money_values (moneyValues_in : moneyValues_in Js.t)
  : moneyValues Js.t =
  execute_or_throw_error
    (fun () ->
       moneyValues_in
       |> moneyValues_in_of_js
       |> money_values
       |> moneyValues_to_js)


let date_values (dateValues_in : dateValues_in Js.t)
  : dateValues Js.t =
  execute_or_throw_error
    (fun () ->
       dateValues_in
       |> dateValues_in_of_js
       |> date_values
       |> dateValues_to_js)


let ambiguous_date (ambiguousDate_in : ambiguousDate_in Js.t)
  : ambiguousDate Js.t =
  execute_or_throw_error
    (fun () ->
       ambiguousDate_in
       |> ambiguousDate_in_of_js
       |> ambiguous_date
       |> ambiguousDate_to_js)


let ambiguous_date2 (ambiguousDate2_in : ambiguousDate2_in Js.t)
  : ambiguousDate2 Js.t =
  execute_or_throw_error
    (fun () ->
       ambiguousDate2_in
       |> ambiguousDate2_in_of_js
       |> ambiguous_date2
       |> ambiguousDate2_to_js)


let ambiguous_date3 (ambiguousDate3_in : ambiguousDate3_in Js.t)
  : ambiguousDate3 Js.t =
  execute_or_throw_error
    (fun () ->
       ambiguousDate3_in
       |> ambiguousDate3_in_of_js
       |> ambiguous_date3
       |> ambiguousDate3_to_js)


let list_values (listValues_in : listValues_in Js.t)
  : listValues Js.t =
  execute_or_throw_error
    (fun () ->
       listValues_in
       |> listValues_in_of_js
       |> list_values
       |> listValues_to_js)


let use_of_tuple (useOfTuple_in : useOfTuple_in Js.t)
  : useOfTuple Js.t =
  execute_or_throw_error
    (fun () ->
       useOfTuple_in
       |> useOfTuple_in_of_js
       |> use_of_tuple
       |> useOfTuple_to_js)


let apply_rates (applyRates_in : applyRates_in Js.t)
  : applyRates Js.t =
  execute_or_throw_error
    (fun () ->
       applyRates_in
       |> applyRates_in_of_js
       |> apply_rates
       |> applyRates_to_js)


let new_income_tax_computation_fixed
  (newIncomeTaxComputationFixed_in : newIncomeTaxComputationFixed_in Js.t)
  : newIncomeTaxComputationFixed Js.t =
  execute_or_throw_error
    (fun () ->
       newIncomeTaxComputationFixed_in
       |> newIncomeTaxComputationFixed_in_of_js
       |> new_income_tax_computation_fixed
       |> newIncomeTaxComputationFixed_to_js)


let new_income_tax_computation
  (newIncomeTaxComputation_in : newIncomeTaxComputation_in Js.t)
  : newIncomeTaxComputation Js.t =
  execute_or_throw_error
    (fun () ->
       newIncomeTaxComputation_in
       |> newIncomeTaxComputation_in_of_js
       |> new_income_tax_computation
       |> newIncomeTaxComputation_to_js)


let include_in_gross_income
  (includeInGrossIncome_in : includeInGrossIncome_in Js.t)
  : includeInGrossIncome Js.t =
  execute_or_throw_error
    (fun () ->
       includeInGrossIncome_in
       |> includeInGrossIncome_in_of_js
       |> include_in_gross_income
       |> includeInGrossIncome_to_js)


let basis_for_fine_determination
  (basisForFineDetermination_in : basisForFineDetermination_in Js.t)
  : basisForFineDetermination Js.t =
  execute_or_throw_error
    (fun () ->
       basisForFineDetermination_in
       |> basisForFineDetermination_in_of_js
       |> basis_for_fine_determination
       |> basisForFineDetermination_to_js)


let test4bis (test4bis_in : test4bis_in Js.t)
  : test4bis Js.t =
  execute_or_throw_error
    (fun () -> test4bis_in |> test4bis_in_of_js |> test4bis |> test4bis_to_js)


let test5 (test5_in : test5_in Js.t)
  : test5 Js.t =
  execute_or_throw_error
    (fun () -> test5_in |> test5_in_of_js |> test5 |> test5_to_js)


let test6 (test4_in : test4_in Js.t)
  : test4 Js.t =
  execute_or_throw_error
    (fun () -> test4_in |> test4_in_of_js |> test6 |> test4_to_js)


let test7 (test3_in : test3_in Js.t)
  : test3 Js.t =
  execute_or_throw_error
    (fun () -> test3_in |> test3_in_of_js |> test7 |> test3_to_js)


let test8 (test2_in : test2_in Js.t)
  : test2 Js.t =
  execute_or_throw_error
    (fun () -> test2_in |> test2_in_of_js |> test8 |> test2_to_js)


let test9 (test1_in : test1_in Js.t)
  : test1 Js.t =
  execute_or_throw_error
    (fun () -> test1_in |> test1_in_of_js |> test9 |> test1_to_js)


let () =
   Js.export "TutorialEnLib"
    (object%js
      
      method incomeTaxComputation_ : (incomeTaxComputation_in Js.t -> incomeTaxComputation Js.t) Js.callback =
        Js.wrap_callback income_tax_computation
      
      method child_ : (child_in Js.t -> child Js.t) Js.callback =
        Js.wrap_callback child
      
      method twoBracketsTaxComputation_ : (twoBracketsTaxComputation_in Js.t -> twoBracketsTaxComputation Js.t) Js.callback =
        Js.wrap_callback two_brackets_tax_computation
      
      method wealthTax_ : (wealthTax_in Js.t -> wealthTax Js.t) Js.callback =
        Js.wrap_callback wealth_tax
      
      method booleanValues_ : (booleanValues_in Js.t -> booleanValues Js.t) Js.callback =
        Js.wrap_callback boolean_values
      
      method integerValues_ : (integerValues_in Js.t -> integerValues Js.t) Js.callback =
        Js.wrap_callback integer_values
      
      method decimalValues_ : (decimalValues_in Js.t -> decimalValues Js.t) Js.callback =
        Js.wrap_callback decimal_values
      
      method moneyValues_ : (moneyValues_in Js.t -> moneyValues Js.t) Js.callback =
        Js.wrap_callback money_values
      
      method dateValues_ : (dateValues_in Js.t -> dateValues Js.t) Js.callback =
        Js.wrap_callback date_values
      
      method ambiguousDate_ : (ambiguousDate_in Js.t -> ambiguousDate Js.t) Js.callback =
        Js.wrap_callback ambiguous_date
      
      method ambiguousDate2_ : (ambiguousDate2_in Js.t -> ambiguousDate2 Js.t) Js.callback =
        Js.wrap_callback ambiguous_date2
      
      method ambiguousDate3_ : (ambiguousDate3_in Js.t -> ambiguousDate3 Js.t) Js.callback =
        Js.wrap_callback ambiguous_date3
      
      method listValues_ : (listValues_in Js.t -> listValues Js.t) Js.callback =
        Js.wrap_callback list_values
      
      method useOfTuple_ : (useOfTuple_in Js.t -> useOfTuple Js.t) Js.callback =
        Js.wrap_callback use_of_tuple
      
      method applyRates_ : (applyRates_in Js.t -> applyRates Js.t) Js.callback =
        Js.wrap_callback apply_rates
      
      method newIncomeTaxComputationFixed_ : (newIncomeTaxComputationFixed_in Js.t -> newIncomeTaxComputationFixed Js.t) Js.callback =
        Js.wrap_callback new_income_tax_computation_fixed
      
      method newIncomeTaxComputation_ : (newIncomeTaxComputation_in Js.t -> newIncomeTaxComputation Js.t) Js.callback =
        Js.wrap_callback new_income_tax_computation
      
      method includeInGrossIncome_ : (includeInGrossIncome_in Js.t -> includeInGrossIncome Js.t) Js.callback =
        Js.wrap_callback include_in_gross_income
      
      method basisForFineDetermination_ : (basisForFineDetermination_in Js.t -> basisForFineDetermination Js.t) Js.callback =
        Js.wrap_callback basis_for_fine_determination
      
      method test4bis_ : (test4bis_in Js.t -> test4bis Js.t) Js.callback =
        Js.wrap_callback test4bis
      
      method test5_ : (test5_in Js.t -> test5 Js.t) Js.callback =
        Js.wrap_callback test5
      
      method test6_ : (test4_in Js.t -> test4 Js.t) Js.callback =
        Js.wrap_callback test6
      
      method test7_ : (test3_in Js.t -> test3 Js.t) Js.callback =
        Js.wrap_callback test7
      
      method test8_ : (test2_in Js.t -> test2 Js.t) Js.callback =
        Js.wrap_callback test8
      
      method test9_ : (test1_in Js.t -> test1 Js.t) Js.callback =
        Js.wrap_callback test9
      
    end)